# Результати тестування

Insertion Sort: 3.110349400085397 seconds
Merge Sort: 0.02861010003834963 seconds
Timsort: 0.0015807000454515219 seconds

# Висновки

З результатів виконання можна зробити наступні висновки:

Ефективність Timsort: Timsort показав найкращий час виконання серед трьох алгоритмів. 
Це підтверджує, що Timsort є надзвичайно ефективним на практиці, особливо на різноманітних типах даних, 
завдяки його адаптивності та гібридному підходу, що поєднує сортування вставками та сортування злиттям.

Переваги сортування злиттям: Сортування злиттям також показало добрі результати, 
значно випереджаючи сортування вставками за швидкістю. Це очікувано, оскільки сортування злиттям має 
часову складність O(n log n) незалежно від вхідних даних, що робить його дуже ефективним для великих масивів.

Обмеження сортування вставками: Незважаючи на те, що сортування вставками може бути дуже швидким на маленьких масивах 
або майже відсортованих даних, воно значно поступається за ефективністю на великих масивах з випадковим 
порядком елементів, що підтверджено найбільшим часом виконання в цьому тесті. 
Це пов'язано з квадратичною часовою складністю (O(n²)) в найгіршому та середньому випадках.
---
Вибір алгоритму сортування: Результати демонструють, чому Timsort використовується як стандартний 
алгоритм сортування в багатьох мовах програмування, включно з Python. 
Він забезпечує високу ефективність на широкому спектрі даних завдяки своїй адаптивності та оптимізації. 
У той же час, це також підкреслює, що вибір алгоритму сортування повинен базуватися на розмірі даних та їх початковому порядку: 
для невеликих або майже відсортованих масивів сортування вставками може бути достатньо ефективним, тоді як для більших масивів краще 
використовувати алгоритми з часовою складністю O(n log n), такі як сортування злиттям або Timsort.
